# Enhanced GitHub Actions Workflow for Production-Ready LLM Application
name: Enhanced RAG Application CI/CD

on:
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
  pull_request:
    branches:
      - main
      - develop

permissions:
  id-token: write
  contents: read
  security-events: write

env:
  REGISTRY: ${{ secrets.AWS_ECR_LOGIN_URI }}
  REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Code Quality and Security Checks
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black isort bandit safety
          pip install -r requirements.txt

      - name: Code Formatting Check (Black)
        run: |
          echo "Checking code formatting with Black..."
          black --check --diff app/

      - name: Import Sorting Check (isort)
        run: |
          echo "Checking import sorting with isort..."
          isort --check-only --diff app/

      - name: Linting (Flake8)
        run: |
          echo "Running linting with Flake8..."
          flake8 app/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 app/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Security Scan (Bandit)
        run: |
          echo "Running security scan with Bandit..."
          bandit -r app/ -f json -o bandit-report.json || true
          bandit -r app/ || true

      - name: Dependency Security Check
        run: |
          echo "Checking for known security vulnerabilities..."
          safety check --json || true

      - name: Upload Security Reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
          retention-days: 30

  # Unit and Integration Tests
  test:
    name: Tests
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11']
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install System Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg libsndfile1 portaudio19-dev

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-flask pytest-mock pytest-cov
          pip install -r requirements.txt

      - name: Create Test Environment
        run: |
          mkdir -p test_logs test_vector_db test_audio
          echo "GROQ_API_KEY=test_key" > .env
          echo "AWS_ACCESS_KEY=test_key" >> .env
          echo "AWS_SECRET_KEY=test_secret" >> .env
          echo "AWS_BUCKET_NAME=test-bucket" >> .env
          echo "OPENAI_API_KEY=test_key" >> .env

      - name: Run Unit Tests
        run: |
          echo "Running unit tests..."
          python -m pytest tests/ -v --cov=app --cov-report=xml --cov-report=html || echo "Tests completed with status $?"

      - name: Upload Test Results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results-${{ matrix.python-version }}
          path: |
            htmlcov/
            coverage.xml
          retention-days: 30

      - name: Application Health Check
        run: |
          echo "Starting application for health check..."
          timeout 30s python app/main.py &
          sleep 10
          curl -f http://localhost:8080/health || echo "Health check failed"

  # Build and Security Scan Docker Image
  build-and-scan:
    name: Build & Security Scan
    runs-on: ubuntu-latest
    needs: [code-quality, test]
    outputs:
      image: ${{ steps.build.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}:${{ env.IMAGE_TAG }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}:latest
          build-args: |
            WHISPER_MODEL=base
            TTS_MODEL=tts_models/en/ljspeech/tacotron2-DDC
            LOG_LEVEL=INFO
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Install Trivy
        run: |
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy

      - name: Security Scan with Trivy
        run: |
          echo "Running container security scan..."
          trivy image --format sarif --output trivy-results.sarif ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}:${{ env.IMAGE_TAG }}
          trivy image --severity HIGH,CRITICAL ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}:${{ env.IMAGE_TAG }}

      - name: Upload Trivy Scan Results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: trivy-results.sarif

  # Deployment to Production
  deploy-production:
    name: Deploy to Production
    runs-on: self-hosted
    needs: [build-and-scan]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: http://your-domain.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create Production Environment
        run: |
          echo "Preparing production environment..."
          mkdir -p production_logs production_vector_db production_audio
          
          # Create production environment file
          cat > .env.production << EOF
          FLASK_ENV=production
          LOG_LEVEL=INFO
          GROQ_API_KEY=${{ secrets.GROQ_API_KEY }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_BUCKET_NAME=${{ secrets.AWS_BUCKET_NAME }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          VECTOR_DB_PATH=/app/vector_db
          AUDIO_UPLOAD_FOLDER=/app/temp_audio
          WHISPER_MODEL=base
          TTS_MODEL_NAME=tts_models/en/ljspeech/tacotron2-DDC
          EOF

      - name: Pull Latest Docker Image
        run: |
          echo "Pulling latest image..."
          docker pull ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}:${{ env.IMAGE_TAG }}

      - name: Stop and Remove Existing Container
        run: |
          echo "Stopping existing container..."
          docker ps -q --filter "name=rag-app" | grep -q . && docker stop rag-app && docker rm -f rag-app || echo "No existing container"

      - name: Deploy New Container
        run: |
          echo "Deploying new container..."
          docker run -d \
            --name=rag-app \
            --restart=unless-stopped \
            -p 8080:8080 \
            --env-file .env.production \
            -v $(pwd)/production_logs:/app/logs \
            -v $(pwd)/production_vector_db:/app/vector_db \
            -v $(pwd)/production_audio:/app/temp_audio \
            --memory=4g \
            --cpus="2.0" \
            --health-cmd="curl -f http://localhost:8080/health || exit 1" \
            --health-interval=30s \
            --health-timeout=30s \
            --health-start-period=60s \
            --health-retries=3 \
            ${{ steps.login-ecr.outputs.registry }}/${{ env.REPOSITORY }}:${{ env.IMAGE_TAG }}

      - name: Wait for Application Startup
        run: |
          echo "Waiting for application to start..."
          timeout 120s bash -c 'until curl -f http://localhost:8080/health; do sleep 5; done'

      - name: Run Health Checks
        run: |
          echo "Running comprehensive health checks..."
          
          # Basic health check
          curl -f http://localhost:8080/health
          
          # Service info check
          curl -f http://localhost:8080/services/info
          
          # Audio info check
          curl -f http://localhost:8080/audio/info
          
          echo "All health checks passed!"

      - name: Setup Monitoring
        run: |
          echo "Setting up monitoring..."
          
          # Create monitoring script
          cat > monitor.sh << 'EOF'
          #!/bin/bash
          while true; do
            if ! curl -f http://localhost:8080/health > /dev/null 2>&1; then
              echo "$(date): Health check failed, restarting container..."
              docker restart rag-app
            fi
            sleep 60
          done
          EOF
          
          chmod +x monitor.sh
          
          # Start monitoring in background (consider using systemd in production)
          nohup ./monitor.sh > monitor.log 2>&1 &

      - name: Clean Up Old Images
        run: |
          echo "Cleaning up old Docker images..."
          docker image prune -f
          docker system prune -f --volumes

      - name: Deployment Summary
        run: |
          echo "Deployment completed successfully!"
          echo "Application URL: http://localhost:8080"
          echo "Health endpoint: http://localhost:8080/health"
          echo "Container status:"
          docker ps --filter "name=rag-app"
          echo "Container logs (last 20 lines):"
          docker logs --tail 20 rag-app

  # Staging Deployment (for develop branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
    
    steps:
      - name: Deploy to Staging Environment
        run: |
          echo "Deploying to staging environment..."
          echo "Image: ${{ needs.build-and-scan.outputs.image }}"
          # Add staging deployment logic here
          
  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always()
    
    steps:
      - name: Deployment Success Notification
        if: needs.deploy-production.result == 'success'
        run: |
          echo "✅ Deployment successful!"
          # Add Slack/email notification logic here
          
      - name: Deployment Failure Notification
        if: needs.deploy-production.result == 'failure'
        run: |
          echo "❌ Deployment failed!"
          # Add failure notification logic here